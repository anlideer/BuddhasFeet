# 抱佛脚罢了

## C++



## C#



## 算法

### 游戏相关

[A*算法](https://blog.csdn.net/hitwhylz/article/details/23089415): 要点是维护open_list, closed_list，还有就是F = G+H，一直这么更新下去直到到达终点





### 排序算法

quicksort (unstable) nlogn~n<sup>2</sup> : partition

mergesort (stable) nlogn: merge

heapsort: min-heap & max-heap 建立最大/最小堆是O(n)，heapsort是O(nlogn)，但性能是比不上实现地比较好的quicksort的，但是堆本身的性质可以很有用（比如priority_queue的原型就是最大/最小堆）

寻找中位数：近期学过的，记住partition的思想就可以，包括配对bolts&nuts也是这样，确定pivot然后partition就可以

分治可以注意的是找fake coin的那个例子，分成三堆是最文明的，虽然只是从log<sub>2</sub> <sup>n</sup> 优化到了log<sub>3</sub> <sup>n</sup>而已，但蛮有意思

#### 线性排序算法

上面很多都是comparision sorts，也就是基于比较输入



## 网络



## 操作系统



## 图形学和shader相关（？

