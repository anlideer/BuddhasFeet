# 抱佛脚罢了

## C++

[贼nm恐怖就](https://juejin.im/post/5cbd7603e51d456e2446fcaf)

### STL

vector封装了数组（vector不能传引用类型，因为引用类型不能赋值，不符合vector的要求（能赋值，能复制）[vector内存申请](https://blog.csdn.net/moonboat0331/article/details/10617731) Vector内存分配使用的是STL的allocator分配器，采用二层分配机制，申请内存大于128K时使用malloc，小于128K时使用内存池

(内存池：避免内存碎片，提高内存申请释放效率) clear和erase都减少vector的size，但不会减少它的capacity [关于内存池](https://blog.csdn.net/K346K346/article/details/49538975)

list封装了链表

map和set封装了二叉树（map是红黑树，准确来讲

priority_queue原型是最大/小堆

unordered_map原型是hash_table（unordered_set好像也是



### 虚函数

- 是C++实现动态单分派子类型多态的方式。

- 纯虚函数是制定一个规范，让继承这个类的类必须实现它，是没有实际实现的函数。（在基类中实现纯虚函数的方法是在函数原型后加“=0”）包含纯虚函数的类是抽象类。

- 虚函数是为了允许用基类的指针来调用子类的这个函数，是确实有实际实现的。

- 在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。

- 友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。
- 析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。
- 构造函数**不可以**是虚函数。我们可能通过基类的指针去销毁对象，但构造函数是创建对象的时候自动调用的，不存在通过父类指针调用构造函数的情况，没有意义。（存储空间上，虚函数对应一个vtable，存储在对象的内存空间。若构造函数是虚的，根本不知道去哪找到vtable）

### 我自己容易糊的*和&

*是指针，表示地址

&是引用，相当于如果是参数传引用的话，那么那个变量指向的地址是跟外面作用域一样的

### OOP

静态多态通过函数重载实现；动态多态通过虚函数实现

**抽象类**是含纯虚函数的类，不能有实例化对象，子类必须实现这个函数。（如果仅含纯虚函数，那么就是接口类）

**虚基类**可以解决二义性（多重继承）的问题，是被virtual继承的类（所有类都可以成为虚基类）。

以上两者没有任何关系。。。

虚继承用于解决多继承条件下的菱形继承问题，一般通过虚基类指针和虚基类表实现。

类模板：template \<class T> 想想STL就知道了

构造函数执行顺序：基类->成员类->自己的；析构函数执行顺序：自己的->成员类->基类

### 内存管理

delete pointer; 是一种操作；只释放内存；跟new配套

free(pointer); 是一个函数；释放内存并且调用那个类的析构函数；跟malloc配套

也就是相当于new：先调用malloc()然后调用构造函数；delete: 先调用free()然后调用析构函数

（不过new申请内存的时候会自动计算所需要的字节数）

delete this是合法的但要保证之后没人再用this而且对象是通过new分配的



若将析构函数设置为私有，则可以保证对象只再堆上生成（因为析构函数无法访问的话就没法在栈上分配

若将new和delete重载为私有，则可以保证只在栈上（因为new会先在堆上查找可用内存并调用构造函数，私有后第一阶段无法执行。

### 智能指针

主要是为了防止内存泄露（因为new之后要delete，但不一定程序就执行得到delete）

是一个类，当超出类的作用范围之后会自动调用析构函数，析构函数会释放资源。

因为进行赋值时，左值会接管右值的内存管理权，所以智能指针最好不要用在容器里（不然就一片NULL了

C++98用的是auto_ptr，后来有了移动语义，诞生了unique_ptr来取代它。

**unique_ptr**：无法进行复制构造和复制赋值等操作（不会有两个指向同一个对象）

保存指向某个对象的指针，当它本身被删除释放的时候，会使用给定的删除器释放它指向的对象

强指针**share_ptr**：资源可以被多个指针共享，使用计数机制来表明资源被几个指针共享。构造+1，release-1（但比如说两个对象互相持有，就两个最后都不会被销毁而且没法互相使用，造成臭名昭著的内存泄露。

弱指针**weak_ptr**：为了解决shared_ptr互相引用时的死锁问题，它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。

注意的是我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa->pb_->print(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr<B> p = pa->pb_.lock();  p->print();

## 数据结构和算法

### 数据结构

stack(FIFO), queue(LIFO), linked list

hash table

binary search trees （二叉搜索树。。。左子树上所有节点小于根节点，右子树上所有节点大于根节点，递归定义

[更多有关二叉树的，完美完全完满](https://www.cnblogs.com/idorax/p/6441043.html)

[红黑树](https://www.jianshu.com/p/e136ec79235c)就是一种自平衡二叉查找树（红黑树是STL里map的原型

### 图相关算法

[A*算法](https://blog.csdn.net/hitwhylz/article/details/23089415): 要点是维护open_list, closed_list，还有就是F = G+H，一直这么更新下去直到到达终点

广度优先(BFS)：Prim和Dijkstra

深度优先(DFS)

#### Prim

算最小生成树，是一种贪心算法。（为N个村庄修路，怎么修花销最小）

（1）：所有的点都在集合B中，A集合为空。(memset(visited,0,sizeof(visited))

 （2）：任意以一个点为开始，把这个初始点加入集合A中，从集合B中减去这个点(visited[1]=1)。寻找与它相邻的点中路径最短的点，如后把这个点也加入集合A中,从集合B中减去这个点（visited[pos]=1）。

 （3）：更新未被访问的节点的dist[]值。

 （4）：重复上述过程。一直到所有的点都在A集合中结束

#### Dijkstra

算最短路径。（从起点到终点最短的路径）

**区分这两个算法可以看有没有给出明确的起点和终点**

（1）初始时，S只包含源点v，即S＝v。U包含除v外的其他顶点，U中顶点u距离为边上的权（若v与u有边）或（若u不是v的出边邻接点）。

（2）从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度）。

（3）以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u（u U）的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。

（4）重复步骤（2）和（3）直到所有顶点都包含在S中。（直到终点加入S才对？


### 排序算法

bubble-sort, insertion-sort, ...

quicksort (unstable) nlogn~n<sup>2</sup> : partition

mergesort (stable) nlogn: merge

heapsort: min-heap & max-heap 建立最大/最小堆是O(n)，heapsort是O(nlogn)，但性能是比不上实现地比较好的quicksort的，但是堆本身的性质可以很有用（比如priority_queue的原型就是最大/最小堆）

寻找中位数：近期学过的，记住partition的思想就可以，包括配对bolts&nuts也是这样，确定pivot然后partition就可以

找第i大的：也是random_partition的思想（跟找中位数是一模一样的）

分治可以注意的是找fake coin的那个例子，分成三堆是最文明的，虽然只是从log<sub>2</sub> <sup>n</sup> 优化到了log<sub>3</sub> <sup>n</sup>而已，但蛮有意思

寻找最大/最小：本来要比较2n次，通过先将元素pair然后互相比较（n/2次），再将其中小的那个跟min比较，大的跟max比较（n次），可以减少到3/2n次



#### 线性排序算法

上面很多都是comparison sorts，也就是基于比较输入，这样的算法总要比较nlogn次，所以O(nlogn)，可用决策树证明，最坏情况就是树的高度h, n! <= l <= 2<sup>h</sup> 可以推出h>=lg(n!) = omega(nlgn)

而下面这三种典型的线性排序算法，对输入都有一些特定的要求（毕竟它们并不依赖于比较输入

##### counting sort 计数排序

输入都在0-k之间，如果k=O(n)，那么整个算法就会是theta(n)

因为知道范围，所以可以直接把数字放在应该在的地方

为了处理重复的数，一开始就用辅助数组去统计好0-k每一个数出现了多少次，然后依照这个去开辟结果数组，一个个处理输入数组的数，放在应该放的地方

##### radix sort 基数排序

used by card-sorting machines（非常远古

思想是按位数切割，然后比较每一位。

从个位（也就是最不重要的一位）开始比较并排序，然后是十位、百位......处理完所有的位数之后就完成了

对单独某一位的排序可以使用任意一个排序，但如果用了counting sort的话，需要注意的是内存消耗。如果内存很昂贵，那么不如用in-placement的那种算法，比如quicksort（quicksort能更好的利用cache之类的

##### bucket sort 桶排序

假设input均匀的分布在[0,1)里

n个元素，n个桶

桶中采用插入排序，插入排序的复杂度是常数E[n<sup>2</sup>]=V[n]+E<sup>2</sup>[n] = 1 - 1/n + 1<sup>2</sup> = O(1) (服从二项分布)



## 网络

[面试总结](https://juejin.im/post/5b7be0b2e51d4538db34a51e)

- 应用层：通过应用进程间的交互来完成特定网络应用。（DNS, HTTP, SMTP）
- 运输层：负责向两台主机进程之间的通信提供通用的数据传输服务。（TCP/UDP）
- 网络层：负责为分组交换网上的不同主机提供通信服务。(TCP/IP体系中使用IP协议)
- 数据链路层：将网络层交下来的IP数据报组装成帧
- 物理层：实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。

TCP握手挥手：三次握手主要是为了双方确认双方发送和接收都正常；四次挥手FIN-ACK-发送剩余数据-FIN-ACK

### TCP和UDP

一般即时通信用UDP；文件传输、收发邮件、远程登录之类的用TCP

对于游戏服务器的话，一般除了动作游戏等无法使用任何延缓延迟措施的游戏之外都可以用TCP（因为可以容忍延迟，而且可以巧妙的让客户端不等待服务端确认直接开始计算，来隐藏可能的延迟。比如说，发送攻击指令之后，直接开始放特效，或者说卡牌类游戏的抽牌动画之类的小动画都可以隐藏可能的延迟。

### TCP保证可靠传输的方法

每个包进行编号；校验和；接收端丢弃重复数据；流量控制（滑动窗口协议）；拥塞控制（慢开始，拥塞避免，快重传，快恢复）；停止等待协议（超时重传...）

### 打开一个网页的过程

- 查找域名的IP地址（DNS协议）
- 浏览器向web服务器发送一个HTTP请求
- 服务器处理请求
- 服务器返回一个HTML响应
- 浏览器开始显示HTML

### 同步

[看这个]([https://www.lt-tree.com/2019/09/21/%E8%81%94%E7%BD%91%E6%88%98%E6%96%97%E5%90%8C%E6%AD%A5%E5%AE%9E%E7%8E%B0/](https://www.lt-tree.com/2019/09/21/联网战斗同步实现/))

帧同步，状态同步。

基本上除了状态同步流量远高于帧同步之外，（以及不严格确定性）基本上还是比帧同步要好的...

[惹，打脸了，农药用的DIY手动组装可靠UDP+帧同步](https://gameinstitute.qq.com/community/detail/116978)，应该好好研究下王者的......

[王者后台分享，好好看，好nb，舔](https://gameinstitute.qq.com/course/detail/10036)



## 操作系统

[struct和union占用空间的计算](https://blog.csdn.net/u012571728/article/details/53583904), 记住32位机器是4字节对齐，64位是8字节对齐（补齐最后面的空间）

### 四个特性

并发 共享 虚拟 异步

### 主要功能

CPU管理，内存管理，设备管理，文件管理，提供用户接口

### 三个核心状态

就绪和运行互转都是调度的事情，时间片用完就会回到就绪

运行->阻塞主要是因为进程请求某一资源的使用和分配或者等待某事发生

阻塞->就绪：等待的事件到来了，或者中断结束

### 进程通信

共享存储，消息传递，管道通信

### 进程同步

空闲让进，忙则等待，优先等待，让权等待

解决方案：管程（是一种数据结构monitor，保证在一个时间点最多只有一个线程在执行管程的某个子程序。由局部于自己的若干公共变量和所有访问这些公共变量的过程组成的），信号量

### 用户态->核心态

系统调用，异常，中断

### 死锁

条件：互斥，请求和保持，不可剥夺，环路等待

### 进程调度

先来先服务，短作业优先，高响应比，时间片轮转，多级反馈队列调度（目前公认比较好的。有多个优先级不一样的就绪队列，优先级越高分到的时间片越短，队列内先来先服务，没有执行完的进程就放入下一个队列，只有一个队列完成了才会开始下一个。

### 内存管理（分段分页）

页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制；段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制

页的大小是固定的，由系统决定；段的大小是不确定的，由用户决定

### 虚拟内存

基本就是把暂时不需要的内容换到外存上去，需要的才在内存里。所以看起来可以有更大的容量。

**页面置换算法**：先进先出，最近最久未使用，时钟clock，改进型clock，最少使用



## Unity 游戏相关

### AssetBundle

AssetBundle是将资源使用Unity提供的一种用于存储资源的压缩格式打包后的集合，它可以存储任何一种Unity可以识别的资源，如模型，纹理图，音频，场景等资源。也可以加载开发者自定义的二进制文件。他们的文件类型是.assetbundle/.unity3d,他们先前被设计好，很容易就下载到我们的游戏或者场景当中。

流程：

- 创建Asset Bundle（通过脚本将所需资源打包成Asset Bundle
- 上传服务器
- 用户下载Asset Bundle
- 通过Unity提供的API加载Asset Bundle，用它来更新游戏客户端
- 卸载AssetBundle，节约资源

### Animator和Animation

Animation貌似是历史遗留了

Animator的话是必须使用状态机的，Animation就只是单个动画。

### 对象池

用于减少内存开销。

其原理就是把可能用到到的对象，先存在一个地方（池），要用的时候就调出来，不用就放回去。而不是要用的时候创建，不用的时候销毁。

把池子搞成单例(static)，池子本身也可以放大缩小啥的，全看程序员控制。

封装成ScriptObject之后，就可以用于任何物体。

### 重要路径

[看这个就好，不想抄了](https://blog.csdn.net/u012138730/article/details/81143413)

### 游戏AI

[行为树和状态机](https://gameinstitute.qq.com/community/detail/118350)

行为树更像策划层面的，而实现层面则依赖状态机。